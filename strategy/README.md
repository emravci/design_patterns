Reference : Klaus Iglberg. C++ Software Design. Design principles and patterns for high-quality software.
# classic implementation
* In this example, it does not require to overload the function (MaterialCostStrategy::cost here) for different Shape family classes (Circle, Square). However, as in the example in the book, it may. When it does and when a new type is added, MaterialCostStrategy abstract class needs to be modified, which would trigger recompilation of any class derived from MaterialCostStrategy. A solution to that is to create an abstract and concrete class for each type such as MaterialCostCircleStrategy, MaterialCostSquareStrategy etc. In order not to create multiple abstract classes, C++ templates can be employed such as MaterialCostStrategy< Circle >, MaterialCostStrategy< Square > etc. With this approach, the number of base classes are the same; however, they are compiler-generated. Most of the work also remains the same because classes derived from those still need implementation.
